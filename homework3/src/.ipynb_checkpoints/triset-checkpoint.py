{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "79c9530c-f7a3-4181-9b00-629e07999840",
   "metadata": {},
   "outputs": [],
   "source": [
    "from typing import Tuple, Callable, Set, DefaultDict, FrozenSet\n",
    "from collections import defaultdict\n",
    "from scipy.stats import bernoulli\n",
    "from functools import reduce\n",
    "import random\n",
    "\n",
    "\n",
    "def parse_edge(line: str) -> FrozenSet[int]:\n",
    "    \"\"\"\n",
    "    Parses a line from the input file and returns a frozenset representing an edge.\n",
    "    \"\"\"\n",
    "    return frozenset([int(node) for node in line.split()])\n",
    "\n",
    "\n",
    "class TriangleCounter:\n",
    "    \"\"\"\n",
    "    Base class for implementing TRIÈST algorithms to estimate triangles in a graph.\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, file_path: str, max_memory: int, verbose: bool = True):\n",
    "        \"\"\"\n",
    "        Initialize the triangle counter with necessary parameters.\n",
    "\n",
    "        :param file_path: Path to the input data file.\n",
    "        :param max_memory: Maximum number of edges to store in memory.\n",
    "        :param verbose: Whether to print detailed logs during execution.\n",
    "        \"\"\"\n",
    "        self.file_path: str = file_path\n",
    "        self.max_memory: int = max_memory\n",
    "        self.verbose: bool = verbose\n",
    "        self.edge_set: Set[FrozenSet[int]] = set()\n",
    "        self.edge_count: int = 0\n",
    "        self.vertex_triangle_map: DefaultDict[int, int] = defaultdict(int)\n",
    "        self.global_triangle_count: int = 0\n",
    "\n",
    "    @property\n",
    "    def scale_factor(self) -> float:\n",
    "        \"\"\"\n",
    "        Computes the scaling factor for triangle estimation.\n",
    "        \"\"\"\n",
    "        return max(\n",
    "            1.0,\n",
    "            (self.edge_count * (self.edge_count - 1) * (self.edge_count - 2))\n",
    "            / (self.max_memory * (self.max_memory - 1) * (self.max_memory - 2))\n",
    "        )\n",
    "\n",
    "    def should_store_edge(self, current_count: int) -> bool:\n",
    "        \"\"\"\n",
    "        Determines whether a given edge should be stored in memory.\n",
    "\n",
    "        :param current_count: Current index of the edge in the stream.\n",
    "        :return: True if the edge should be stored, False otherwise.\n",
    "        \"\"\"\n",
    "        if current_count <= self.max_memory:\n",
    "            return True\n",
    "        if bernoulli.rvs(p=self.max_memory / current_count):\n",
    "            edge_to_remove: FrozenSet[int] = random.choice(list(self.edge_set))\n",
    "            self.edge_set.remove(edge_to_remove)\n",
    "            self.update_triangle_counters(lambda x, y: x - y, edge_to_remove)\n",
    "            return True\n",
    "        return False\n",
    "\n",
    "    def update_triangle_counters(self, operation: Callable[[int, int], int], edge: FrozenSet[int]) -> None:\n",
    "        \"\"\"\n",
    "        Updates triangle counts for the edge and its neighbors.\n",
    "\n",
    "        :param operation: The operation to apply to the counters (e.g., addition or subtraction).\n",
    "        :param edge: The edge being processed.\n",
    "        \"\"\"\n",
    "        common_neighbors: Set[int] = reduce(\n",
    "            lambda a, b: a & b,\n",
    "            [\n",
    "                {neighbor for edge_pair in self.edge_set if vertex in edge_pair for neighbor in edge_pair if neighbor != vertex}\n",
    "                for vertex in edge\n",
    "            ],\n",
    "        )\n",
    "\n",
    "        for neighbor in common_neighbors:\n",
    "            self.global_triangle_count = operation(self.global_triangle_count, 1)\n",
    "            self.vertex_triangle_map[neighbor] = operation(self.vertex_triangle_map[neighbor], 1)\n",
    "            for vertex in edge:\n",
    "                self.vertex_triangle_map[vertex] = operation(self.vertex_triangle_map[vertex], 1)\n",
    "\n",
    "\n",
    "class BasicTriangleCounter(TriangleCounter):\n",
    "    \"\"\"\n",
    "    Implements the basic TRIÈST algorithm for triangle counting.\n",
    "    \"\"\"\n",
    "\n",
    "    def execute(self) -> float:\n",
    "        \"\"\"\n",
    "        Executes the basic TRIÈST algorithm on the input data.\n",
    "\n",
    "        :return: Estimated number of triangles.\n",
    "        \"\"\"\n",
    "        if self.verbose:\n",
    "            print(f\"Running the algorithm with memory size = {self.max_memory}.\")\n",
    "\n",
    "        with open(self.file_path, 'r') as data_file:\n",
    "            if self.verbose:\n",
    "                print(\"Reading input data...\")\n",
    "\n",
    "            for line in data_file:\n",
    "                edge = parse_edge(line)\n",
    "                self.edge_count += 1\n",
    "\n",
    "                if self.verbose and self.edge_count % 1000 == 0:\n",
    "                    print(f\"Processed {self.edge_count} edges.\")\n",
    "\n",
    "                if self.should_store_edge(self.edge_count):\n",
    "                    self.edge_set.add(edge)\n",
    "                    self.update_triangle_counters(lambda x, y: x + y, edge)\n",
    "\n",
    "                if self.verbose and self.edge_count % 1000 == 0:\n",
    "                    print(f\"Estimated triangle count: {self.scale_factor * self.global_triangle_count}\")\n",
    "\n",
    "            return self.scale_factor * self.global_triangle_count\n",
    "\n",
    "\n",
    "class ImprovedTriangleCounter(TriangleCounter):\n",
    "    \"\"\"\n",
    "    Implements the improved TRIÈST algorithm for triangle counting.\n",
    "    \"\"\"\n",
    "\n",
    "    @property\n",
    "    def adjustment_factor(self) -> float:\n",
    "        \"\"\"\n",
    "        Computes the adjustment factor for improved triangle estimation.\n",
    "        \"\"\"\n",
    "        return max(1.0, ((self.edge_count - 1) * (self.edge_count - 2)) / (self.max_memory * (self.max_memory - 1)))\n",
    "\n",
    "    def update_triangle_counters(self, operation: Callable[[int, int], int], edge: FrozenSet[int]) -> None:\n",
    "        \"\"\"\n",
    "        Updates triangle counts using the improved estimation method.\n",
    "\n",
    "        :param operation: The operation to apply to the counters.\n",
    "        :param edge: The edge being processed.\n",
    "        \"\"\"\n",
    "        common_neighbors: Set[int] = reduce(\n",
    "            lambda a, b: a & b,\n",
    "            [\n",
    "                {neighbor for edge_pair in self.edge_set if vertex in edge_pair for neighbor in edge_pair if neighbor != vertex}\n",
    "                for vertex in edge\n",
    "            ],\n",
    "        )\n",
    "\n",
    "        for neighbor in common_neighbors:\n",
    "            self.global_triangle_count += self.adjustment_factor\n",
    "            self.vertex_triangle_map[neighbor] += self.adjustment_factor\n",
    "            for vertex in edge:\n",
    "                self.vertex_triangle_map[vertex] += self.adjustment_factor\n",
    "\n",
    "    def execute(self) -> float:\n",
    "        \"\"\"\n",
    "        Executes the improved TRIÈST algorithm on the input data.\n",
    "\n",
    "        :return: Estimated number of triangles.\n",
    "        \"\"\"\n",
    "        if self.verbose:\n",
    "            print(f\"Running the algorithm with memory size = {self.max_memory}.\")\n",
    "\n",
    "        with open(self.file_path, 'r') as data_file:\n",
    "            if self.verbose:\n",
    "                print(\"Reading input data...\")\n",
    "\n",
    "            for line in data_file:\n",
    "                edge = parse_edge(line)\n",
    "                self.edge_count += 1\n",
    "\n",
    "                if self.verbose and self.edge_count % 1000 == 0:\n",
    "                    print(f\"Processed {self.edge_count} edges.\")\n",
    "\n",
    "                self.update_triangle_counters(lambda x, y: x + y, edge)\n",
    "\n",
    "                if self.should_store_edge(self.edge_count):\n",
    "                    self.edge_set.add(edge)\n",
    "\n",
    "                if self.verbose and self.edge_count % 1000 == 0:\n",
    "                    print(f\"Estimated triangle count: {self.global_triangle_count}\")\n",
    "\n",
    "            return self.global_triangle_count\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    ImprovedTriangleCounter(\n",
    "        file_path='../data/facebook_combined.txt',\n",
    "        max_memory=1000,\n",
    "        verbose=True\n",
    "    ).execute()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.20"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
